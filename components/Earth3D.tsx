import React, { useMemo, useRef, useState, Suspense, useEffect } from 'react';
import { Canvas, useFrame, extend, useLoader, useThree, ThreeEvent } from '@react-three/fiber';
import { OrbitControls, Stars } from '@react-three/drei';
import * as THREE from 'three';
import { SatellitePos } from '../types';

// Extend Three.js Line
extend({ ThreeLine: THREE.Line });

// Create a type-safe alias to avoid SVG collision and TS errors without @ts-ignore
// 'threeLine' is the string key generated by extend({ ThreeLine: ... })
const OrbitLineImpl = 'threeLine' as unknown as React.FC<any>;

// Earth Radius in scene units
const R = 1; 

interface EarthProps {
  satellites: SatellitePos[];
  onSatClick?: (sat: SatellitePos) => void;
}

const Atmosphere = () => {
    return (
        <mesh scale={[1.02, 1.02, 1.02]}>
            <sphereGeometry args={[R, 64, 64]} />
            <meshPhongMaterial 
                color="#87CEEB" 
                transparent 
                opacity={0.1} 
                side={THREE.BackSide} 
                blending={THREE.AdditiveBlending}
                depthWrite={false}
            />
        </mesh>
    )
}

const EarthMesh = () => {
  const { gl } = useThree();
  
  // Use reliable textures from Three.js examples
  const [colorMap, normalMap, specularMap] = useLoader(THREE.TextureLoader, [
      'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
      'https://threejs.org/examples/textures/planets/earth_normal_2048.jpg',
      'https://threejs.org/examples/textures/planets/earth_specular_2048.jpg'
  ]);
  
  // Improve texture clarity
  useMemo(() => {
    const maxAnisotropy = gl.capabilities.getMaxAnisotropy();
    if (colorMap) colorMap.anisotropy = maxAnisotropy;
    if (normalMap) normalMap.anisotropy = maxAnisotropy;
    if (specularMap) specularMap.anisotropy = maxAnisotropy;
  }, [colorMap, normalMap, specularMap, gl]);
  
  return (
    <group>
        <mesh rotation={[0, 0, 0]}>
            <sphereGeometry args={[R, 64, 64]} />
            <meshPhongMaterial 
                map={colorMap} 
                normalMap={normalMap}
                normalScale={new THREE.Vector2(0.5, 0.5)}
                specularMap={specularMap}
                specular={new THREE.Color(0x333333)}
                shininess={5}
            />
        </mesh>
        <Atmosphere />
    </group>
  );
};

interface HoverData {
    sat: SatellitePos;
    x: number;
    y: number;
}

const SatelliteInstances = ({ 
    satellites, 
    onHover,
    onClick
}: { 
    satellites: SatellitePos[], 
    onHover: (data: HoverData | null) => void,
    onClick?: (sat: SatellitePos) => void
}) => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const tempObject = new THREE.Object3D();
  const tempColor = new THREE.Color();

  useFrame(() => {
    if (!meshRef.current) return;
    
    satellites.forEach((sat, i) => {
      tempObject.position.set(sat.x, sat.y, sat.z);
      // Scale down slightly for realism
      const scale = 0.012;
      tempObject.scale.set(scale, scale, scale);
      tempObject.updateMatrix();
      meshRef.current!.setMatrixAt(i, tempObject.matrix);
      meshRef.current!.setColorAt(i, tempColor.set(sat.color || '#ffffff'));
    });
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  const handlePointerMove = (e: ThreeEvent<PointerEvent>) => {
      e.stopPropagation();
      // Determine which instance was hovered
      const instanceId = e.instanceId;
      if (instanceId !== undefined && satellites[instanceId]) {
          onHover({
              sat: satellites[instanceId],
              x: e.clientX,
              y: e.clientY
          });
          // Change cursor to indicate interactivity
          document.body.style.cursor = 'crosshair';
      }
  };

  const handlePointerOut = () => {
      onHover(null);
      document.body.style.cursor = 'default';
  };
  
  const handlePointerDown = (e: ThreeEvent<PointerEvent>) => {
      e.stopPropagation();
      const instanceId = e.instanceId;
      if (instanceId !== undefined && satellites[instanceId] && onClick) {
          onClick(satellites[instanceId]);
      }
  };

  return (
    <instancedMesh 
        ref={meshRef} 
        args={[undefined, undefined, satellites.length]}
        onPointerMove={handlePointerMove}
        onPointerOut={handlePointerOut}
        onPointerDown={handlePointerDown}
    >
      <sphereGeometry args={[1, 12, 12]} />
      <meshBasicMaterial toneMapped={false} />
    </instancedMesh>
  );
};

// Individual Orbit Line component
interface OrbitLineProps {
  path: {x:number, y:number, z:number}[];
  color: string;
}

const OrbitLine: React.FC<OrbitLineProps> = ({ path, color }) => {
  // Create geometry declaratively to avoid memory leaks with manual instantiation
  // We convert path points to a flat array for BufferAttribute
  const points = useMemo(() => {
      const arr = new Float32Array(path.length * 3);
      for(let i=0; i<path.length; i++) {
          arr[i*3] = path[i].x;
          arr[i*3+1] = path[i].y;
          arr[i*3+2] = path[i].z;
      }
      return arr;
  }, [path]);

  if (path.length === 0) return null;

  return (
      <OrbitLineImpl>
          <bufferGeometry>
             <bufferAttribute 
                attach="attributes-position" 
                count={path.length} 
                array={points} 
                itemSize={3} 
             />
          </bufferGeometry>
          <lineBasicMaterial color={color} opacity={0.4} transparent blending={THREE.AdditiveBlending} linewidth={1} />
      </OrbitLineImpl>
  );
};

const Orbits = ({ satellites }: { satellites: SatellitePos[] }) => {
    return (
        <group>
            {satellites.map((sat) => {
                if (!sat.orbitPath || sat.orbitPath.length === 0) return null;
                return <OrbitLine key={`orbit-${sat.id}`} path={sat.orbitPath} color={sat.color || '#06b6d4'} />;
            })}
        </group>
    )
}

const Tooltip = ({ data }: { data: HoverData }) => {
    return (
        <div 
            className="fixed z-50 pointer-events-none p-3 bg-slate-950/90 border border-cyan-500/50 rounded backdrop-blur-md shadow-[0_0_20px_rgba(6,182,212,0.2)] flex flex-col gap-2 min-w-[180px]"
            style={{ 
                left: data.x + 15, 
                top: data.y + 15,
                transform: 'translate(0, 0)' 
            }}
        >
            <div className="flex items-center justify-between border-b border-slate-800 pb-1 mb-1">
                <span className="text-cyan-400 font-bold font-mono text-xs tracking-wider">{data.sat.name}</span>
                <div className="w-2 h-2 rounded-full bg-emerald-500 animate-pulse"></div>
            </div>
            <div className="grid grid-cols-[auto_1fr] gap-x-4 gap-y-1 text-[10px] font-mono text-slate-300">
                <span className="text-slate-500">ALT</span>
                <span className="text-right font-bold">{data.sat.alt.toFixed(1)} KM</span>
                
                <span className="text-slate-500">VEL</span>
                <span className="text-right font-bold">{data.sat.velocity.toFixed(2)} KM/S</span>
                
                <span className="text-slate-500">LAT</span>
                <span className="text-right font-bold">{data.sat.lat.toFixed(2)}°</span>
                
                <span className="text-slate-500">LON</span>
                <span className="text-right font-bold">{data.sat.lon.toFixed(2)}°</span>
            </div>
            
            <div className="text-[9px] text-cyan-500/50 font-mono pt-1 border-t border-slate-800/50 mt-1">
                ID: {data.sat.id} // CLICK FOR DETAILS
            </div>
        </div>
    )
}

const Earth3D: React.FC<EarthProps> = ({ satellites, onSatClick }) => {
  const [hoverData, setHoverData] = useState<HoverData | null>(null);

  return (
    <div className="w-full h-full bg-[#050505] rounded border border-slate-800 relative overflow-hidden shadow-2xl shadow-black group">
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-900/10 via-transparent to-transparent pointer-events-none z-0"></div>
        
        <Canvas camera={{ position: [0, 2, 3.5], fov: 40 }} gl={{ antialias: true, pixelRatio: window.devicePixelRatio }}>
          <ambientLight intensity={0.6} color="#ffffff" /> 
          <directionalLight position={[5, 3, 5]} intensity={2.0} color="#ffffff" castShadow />
          <directionalLight position={[-5, -3, -2]} intensity={0.5} color="#8899aa" />
          
          <Stars radius={300} depth={60} count={2000} factor={4} saturation={0} fade speed={0.5} />
          
          <Suspense fallback={null}>
            <EarthMesh />
          </Suspense>
          
          <SatelliteInstances satellites={satellites} onHover={setHoverData} onClick={onSatClick} />
          <Orbits satellites={satellites} />
          
          <OrbitControls 
            enablePan={false} 
            minDistance={1.8} 
            maxDistance={10} 
            autoRotate 
            autoRotateSpeed={0.3} 
            enableDamping
            dampingFactor={0.05}
          />
        </Canvas>
        
        {hoverData && <Tooltip data={hoverData} />}
        
        {/* Overlay Stats */}
        <div className="absolute bottom-4 left-4 bg-black/80 border border-slate-800 p-3 rounded text-xs font-mono text-cyan-400 pointer-events-none backdrop-blur-md">
            <div className="text-white font-bold mb-1">REAL-TIME TRACKING</div>
            <div>OBJECTS: {satellites.length}</div>
            <div>REF: J2000/ECEF</div>
        </div>
    </div>
  );
};

export default Earth3D;